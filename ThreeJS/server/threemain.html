<html>
	<head>
		<meta charset="UTF-8">
		
		<title>Scratch THREE.JS</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/three.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/CameraControls.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/SceneComponents.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/TrackballControls.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/SceneStyles.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/OBJLoader.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/threex.grassground.js"></script>
		<script src="http://goodwinj14.github.io/ThreeJS/server/threeJScontrols/BlendCharacter.js"></script>
		<script>
		var RENDERER = null;
		var SCENE = null;
		var CAMERA = null;
		var controls = null;
		//Info needed to send data back to the parent window
		var origin = null;
		var messageSource = null;
		//Set the alpha of the scene
		//Important becuase when we switch between grass and grid 
		//The aplph must change to make the scene look best
		var alpha=false;
		/*
		*EVENT HANDELER BEGIN
		*/
		//The event handeler to deligate the message events
		//To there proper corisponding function calles
		var event;
	
		window.addEventListener("message", eventHandeler, false);

		function eventHandeler(){
			//Gets the address from which the event came
			console.log(event);
			if(origin==null || messageSource==null){
				origin = event.origin;
				messageSource = event.source;
			}

			//Retrevies the command Key of the message denoting which function to call
			var commandKey = event.data.split("_")[0];
			//Retervies the paramiters of the message for the corasponding function call if message contains params
			var paramsArray = null;
			console.log("Event Called: ", commandKey);
			if(event.data.split("_").length>1){
			paramsArray = event.data.split("_")[1].split(",");
			}
			//INIT Commande is associated with the "New 3D World Block"
			if(commandKey == "INIT"){
				init_window(paramsArray);
			}
			//CAMERAROTATE command tag is associated with Rotate Camera Block
			if(commandKey == "CAMERAROTATE"){
				if(CAMERA!=null){
				console.log("CAMERA ROTATE KEY CALLED");
				CAMERACONTROLS.rotate(paramsArray[0], paramsArray[1], CAMERA);
			}
			}
			//CAMERAORBIT command tag is associated with Orbit Camera Block
			if(commandKey == "CAMERAORBIT"){
				if(CAMERA!=null){
				var orbitPoint = [3];
				orbitPoint[0]= paramsArray[1];
				orbitPoint[1]= paramsArray[2];
				orbitPoint[2]= paramsArray[3];
				CAMERACONTROLS.orbit(paramsArray[0], new THREE.Vector3(0,0,0), 1, CAMERA);
			}
			}
			//CAMERAMOVE command tag is associated with Move Camera Block 
			if(commandKey == "CAMERAMOVE"){
				if(CAMERA!=null){
					CAMERACONTROLS.move(paramsArray[0], parseFloat(paramsArray[1]),CAMERA);
			}
			}
			//SETCAMERACONTROLS
			if(commandKey == "SETCAMERACONTROLS"){
				console.log("paramsArray[0]: ", paramsArray[0]);
				controls = new THREE.TrackballControls(CAMERA);
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', RENDERER );
			}
			//SETCAMERALOOKAT command tag is associated with the Look At Objecet block
			if(commandKey == "SETCAMERALOOKAT"){
				if(CAMERA!=null){
					console.log("SETCAMERALOOKAT:" ,SCENECOMPONENTS.getCharecter(paramsArray[0]));
					//CAMERACONTROLS.lookAt(paramsArray[0],CAMERA); 
			}
			}

			//
			if(commandKey == "ADDCHARECTER"){
				console.log("ADDCHARECTER called");
				SCENECOMPONENTS.addCharecter(paramsArray[0],paramsArray[1],paramsArray[2],paramsArray[3],paramsArray[4],SCENE);
			}
			//CREATESHAPE command tag is associated with the Move block
			if(commandKey == "CREATESHAPE"){
				if(SCENE!=null){
					SCENECOMPONENTS.addShape(paramsArray[0],paramsArray[1],paramsArray[2],paramsArray[3],paramsArray[4],paramsArray[5],paramsArray[6], 					paramsArray[7], SCENE);
					console.log("CREATESHAPE KEY CALLED", paramsArray);
					
					}
				}
			if(commandKey == "MOVESHAPE"){
				if(SCENE!=null){
					SCENECOMPONENTS.move(paramsArray[0],paramsArray[1], paramsArray[2]);
				}
			}
			if(commandKey == "LOADOBJ"){
				if(SCENE!=null){
					SCENECOMPONENTS.addOBJ(paramsArray[0], paramsArray[1], SCENE);
					console.log("LOADOBJ KEY CALLED", paramsArray);
					
				}
			}
		}
		/*
		*EVENT HANDELER END
		*/
		

		/*
		*Detecs Key events in child window and passes them to the parent window to 
		*Be proccesed by scratch.
		*/

		window.addEventListener("keydown", function(e){
			messageSource.postMessage(e.keyCode,origin);
		 });
		
		
		/*
		*THE MAIN INTI FUNCTIONS FOR PRE-SETUP OF THE RENDERER, SCENE AND CAMERA
		*/
		
		function init_window(sceneStyle){
			console.log("Init Window");
			init_Render();
			init_Scene(sceneStyle);
			init_Camera(6,8,5.6);
			
			if(RENDERER==null || SCENE==null || CAMERA==null){
				return false;
			}else {firstRender(SCENE, CAMERA); animate(); console.log("RUNN CALLED"); return true;}
			
		}
		
		//INITIALIZES THE RENDERER OBJECT
		function init_Render(){
			console.log("init_Render");
			RENDERER = new THREE.WebGLRenderer({ alpha: true });
			RENDERER.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(RENDERER.domElement);
		}
		//INITIALIZES THE CAMERA OBJECT
		//@params Y postion, Z postion, X rotation 
		function init_Camera(posY, posZ, rotaX){
			console.log("init_Camera");
			CAMERA = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
			CAMERA.position.y = posY; 
			CAMERA.position.z = posZ;
			CAMERA.rotation.x = rotaX;
			//CAMERA.up.set(1,0,0);
			//Adds the base camera controles
			//controls = new THREE.TrackballControls(CAMERA);
			//controls.addEventListener('change', render);
		}
		//INITIALIZES THE SCENE OBJECT

		function init_Scene(sceneStyle){
			console.log("init_Scene called", sceneStyle[0]);
			SCENE = new THREE.Scene();

			//Creates a basic grid scene
			if(sceneStyle[0]=="Grid"){
			RENDERER = new THREE.WebGLRenderer();
			RENDERER.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(RENDERER.domElement);
			var light	= new THREE.AmbientLight( 0x020202 );
			SCENE.add( light );
			var plane = SCENESTYLES.GRID;
			console.log("GridValue:", plane); 
			SCENE.add(plane);
			}

			////////////////////////////
			//Creates a Flat grass scene
			///////////////////////////
			else if(sceneStyle[0]=="Grass"){
			console.log("Grass called");
			//Straight from https://github.com/jeromeetienne/threex.grassground
			//Thanks jeromeetienne for all the amazing game extentions!!!
			/////////////////////////////////////////////////////////////
			//////////////////////ADD Light//////////////////////////////
			var light	= new THREE.AmbientLight( 0x020202 );
			SCENE.add( light );
			// add a light in front
			var light	= new THREE.DirectionalLight('white', 1);
			light.position.set(0.5, 0.5, 2);
			SCENE.add( light );
			// add a light behind
			var light	= new THREE.DirectionalLight('white', 0.75);
			light.position.set(-0.5, 2.5, -2);
			SCENE.add( light );

			/////////////////////////////////////////////////////////////
			////////////////////////Adds Sky/////////////////////////////
			/////////////////////////////////////////////////////////////
			// directly from @mrdoob in http://mrdoob.com/lab/javascript/webgl/clouds/
			var canvas	= document.createElement( 'canvas' );
			var context	= canvas.getContext( '2d' );
			canvas.width	= 32;
			canvas.height	= window.innerHeight;

			var gradient	= context.createLinearGradient( 0, 0, 0, canvas.height );
			gradient.addColorStop(0  , "#1e4877");
			gradient.addColorStop(0.5, "#4584b4");

			context.fillStyle	= gradient;
			context.fillRect(0, 0, canvas.width, canvas.height);

			var url		= canvas.toDataURL('image/png');
			document.body.style.background	= 'url(' + url + ')';

			/////////////////////////////////////////////////////////////
			////////////////////////Adds Ground//////////////////////////
			/////////////////////////////////////////////////////////////
			var groundMesh  = new THREEx.GrassGround({
			width       : 10,    // the width of the mesh, default to 1
    		height      : 10,    // the height of the mesh, default to 1
    		repeatX     : sceneStyle[1],    // the number of time the texture is repeated in X, default to 1
    		repeatY     : sceneStyle[2],    // the number of time the texture is repeated in Y, default to 1
			});
			console.log("Ground: ",groundMesh);
			//Scales Mesh resulting in a smother grass look gets the average between width and height (((parseInt(sceneStyle[1])+(parseInt(sceneStyle[1]))/2)
			groundMesh.scale.multiplyScalar((parseInt(sceneStyle[1])+parseInt(sceneStyle[1]))/2);
			SCENE.add(groundMesh);
			}
			
		}
		
		//RENDERS THE THE RENDER OBJECT FOR THE FIRST TIME ONCE THE WINDOW IS CREATED
		function firstRender(scene, camera){
			RENDERER.render(scene, camera);
		} 
		function render(){
			RENDERER.render(SCENE, CAMERA);
		} 
		function animate(){
			requestAnimationFrame(animate);
			RENDERER.render(SCENE, CAMERA);
			if(controls!=null){
			controls.update();
			}
		}
		/*
		*
		*/
		</script>
	</body>
</html>