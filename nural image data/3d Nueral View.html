<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body >
	<div >
		<div id="three"  style="float: left;" width="500px" height="500px">
			
		</div>
		<div id="picture"  style="float: left;" >
			
		<canvas id="viewport" width="200" height="100">
		</canvas>
		</div>
		<div id="data">
			
		</div>
	</div>
		<script src="three.js"></script>
		<script src="TrackballControls.js"></script>
		<script>
		//Json formating
		var brainBlock = {
    	postions: [],
    	colors: []
		};
		 var count = 0; 
		 var particleSystem = null;
		 var particles = (240*240)*240;
		 var geometry = new THREE.BufferGeometry();
		 var positions = new Float32Array( particles * 3 );
		 var jsonPostions = [particles * 3 ];
		 var jsonColors = [particles * 3 ];
		 var colors = new Float32Array( particles * 3 );
		 base_image = new Image();
  		 
		 var canvas = document.getElementById('viewport');
		 //var y = new Array(base_image.height*base_image.width);
		 var controls = null;
		 var context = canvas.getContext('2d');

		 
		 
		 loadImg(count);
		 function loadImg(slideNum){
		 	var src = "jpgImages/batch10_image-p19q1927c110s41jko1fvbe1ukrg-"+ slideNum +".jpg";
		 		base_image.src = src;
		 }
		 var i =0;
  		 base_image.onload = function(){
  		 	//console.log(count, "onload");
    	 	canvas.width = base_image.width;
  		 	canvas.height = base_image.height;
    	 	
				
    	 		context.drawImage(base_image, 0, 0);


				var color = new THREE.Color();
				
				
				for ( var y = 0; y < 240; y++ ) {
				for ( var x = 0; x < 240; x++ ) {

					// positions
					
					var x = x;
					var y = y;
					var z = count;

					positions[ i ]     = x;
					//jsonPostions[ i ]     = x;
					positions[ i + 1 ] = -y;
					//jsonPostions[ i + 1 ] = -y;
					positions[ i + 2 ] = z;
					//jsonPostions[ i + 2 ] = z;

					var r = context.getImageData(x, y, 1, 1).data[0]/255;
					var g = context.getImageData(x, y, 1, 1).data[1]/255;
					var b = context.getImageData(x, y, 1, 1).data[2]/255;
					//var r = 0.4;
					color.setRGB(r,b,g);

					colors[ i ]     = color.r;
					//jsonColors[i] = color.r;
					colors[ i + 1 ] = color.g;
					//jsonColors[i + 1] = color.g;
					colors[ i + 2 ] = color.b;
					//jsonColors[i + 2] = color.b;
					i+=3;
					}
				}
			count++;
			if(count<240){
				//context.clearRect(0, 0, canvas.width, canvas.height);
				//base_image.onload();
				loadImg(count);
			}else{
				finish();
				/*brainBlock.colors = JSON.stringify(jsonColors);
				
				colors = window.open("data:text/json," + encodeURIComponent(brainBlock.colors), "_blank");	*/
		}
}

				function finish(){
					console.log("finish");
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

				geometry.computeBoundingSphere();

				//

				var material = new THREE.PointCloudMaterial( { size: 3, vertexColors: THREE.VertexColors } );

				particleSystem = new THREE.PointCloud( geometry, material );
				//particleSystem.position.x = -120;
				//particleSystem.position.y = 120;
				scene.add( particleSystem );
				//particleSystem.rotation.y = 90;
				camera.position.z = 2000;
				//camera.position.x = -100;


			//var cube = new THREE.Mesh( geometry, material );
			/*for (var i = 10; i >= 0; i--) {
				for (var j = base_image.width - 1; j >= 0; j--) {
					var geometry = new THREE.BoxGeometry( .01, .01, .01);
					var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
					var cube = new THREE.Mesh( geometry, material );
					cube.position.x = j*.01;
					cube.position.y = i*(-.01);
					cube.position.z = .01;

					cube.material.color.r =canvas.getContext('2d').getImageData(j, i, 1, 1).data[0]/255;
					cube.material.color.g =canvas.getContext('2d').getImageData(j, i, 1, 1).data[1]/255;
					cube.material.color.b =canvas.getContext('2d').getImageData(j, i, 1, 1).data[2]/255;
					cube.material.color.a =canvas.getContext('2d').getImageData(j, i, 1, 1).data[3]/255;
					scene.add( cube );
					//renderer.render(scene, camera);
					
				};
			};*/
			

    			
 		 }

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight/1.333, 1, 2500 );
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth/1.333, window.innerHeight );
			document.getElementById("three").appendChild( renderer.domElement );
			//var pixelData = canvas.getContext('2d').getImageData(event.offsetX, event.offsetY, 1, 1).data;


			
			
			controls = new THREE.TrackballControls(camera);
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;


			

			camera.position.z = 5;


			function render(){
		
			renderer.render(scene, camera);
		} 
		function animate(){
			requestAnimationFrame(animate);
			var time = Date.now() * 0.001;
				console.log('animating');
				if(particleSystem!=null){
				particleSystem.rotation.x = time * 0.02;
				particleSystem.rotation.y = time * 0.02;
			}
			render();
			controls.update();
		}
			render();
			animate();
		</script>
	</body>
</html>